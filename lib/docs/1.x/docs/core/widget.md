# 部件 Widget

部件（Widget）是页面上的基本逻辑单元。它通过HTML、CSS和JavaScript构建前端的呈现，使用Ajax技术调用后台的服务接口，完成一个或一系列的完整业务功能。

部件是独立和完整的，不依赖于具体的应用程序，也不必须依赖其他部件。因此一个设计良好的部件可以脱离其他部件运行，同时也可以在其他应用程序中使用

## 定义

部件总是被定义成一个方法，这点或许有点难以理解，但考虑到应用程序在调用某个部件时，通过调用某个方法，并传入配置项，比起 `new` 一个对象，并传入配置项，
从好的编码风格上来看，前者似乎更能得到大家的认同

```js
var widget = function(options){
    var View = app.view.define();
    return new View(options);
};
```

我们把定义部件的这个方法称为：部件主函数，部件主函数返回一个对象，称为：部件对象

### 部件对象

应用程序把该返回对象作为部件的实例放入应用所维护的部件实例集合中，以便对部件进行管理，这个对象称为部件对象（Widget Object）。

严格说来，部件主函数返回的对象还不能称之为部件对象，它需要进行包装，附加一些属性，并可能会需要满足一些要求

**附加**

应用程序获取到部件主函数返回的对象后，会附加以下的属性：

* _name：部件的名称
* _ref: 部件的请求路径
* sandbox：部件的沙箱
* options: 如果用户未定义该属性，则系统会附加部件的配置参数到该属性上

以及DOM标记、关联关系等

**部署**

部件对象是每个小部件的实例，它没有规定具体的形式，但大部分应该是一个视图，这称为：主视图。

如果你返回的是一个普通的JavaScript对象或用户自定义的一个对象（一般情况下别这么做）作为部件对象，则可能需要注意一下下面框架对部件对象内部方法进行特殊处理的内容，。

**remove/destroy** `function`

如果部件对象定义了以上两个方法，那么部件销毁时会调用这两个方法

**$el** `object(jquery)`

部件的根元素

如果部件对象拥有此属性，那么应用程序将会在这个元素上添加一些类用于标识该元素是一个veronica部件；
在部件销毁时，如果未提供 `remove` 方法，那么应用程序会默认移除该根元素

综上，部件的定义有两个特征：

* 是一个方法
* 该方法返回一个对象


### 沙箱（sandbox）

在传入部件主函数的配置项中，有个比较重要的对象：沙箱

沙箱是部件与外界联系的媒介，并为每一个部件提供了相对独立的运行环境

```js
var sandbox = this.options.sandbox;
```

> 沙箱在部件初始化时，通过外部配置项传入，并可通过部件主视图的配置项访问，实例化子视图时则需要将沙箱放在子视图配置中传入

你可以简单把沙箱理解为部件的内核，它提供了以下一些功能：

* 唯一标识某个部件

> 同一个部件如果有多个实例，那么它们的沙箱是不同的

一般情况下，你可以通过部件的名称区分不同的部件，但当你要区分同一个部件在页面上共存的多个实例时（当然一般情况下不会这么做），
你通过沙箱标识符去区分它们，每一个实例它们的沙箱一定是不相同的，沙箱具有唯一性

* 部件间通信

部件间通信，传递消息是通过沙箱完成的，因为它本质上具有唯一性，能够正常添加和清除消息而不引起混乱

* 访问框架提供的公共方法

沙箱是部件获取公共对象和方法的唯一入口，因为沙箱能够访问应用程序实例，所有的扩展和公共方法都挂在应用程序对象上

* 管理父级、子级部件

部件间的上下级关系是通过沙箱维持的

## 组织方式

### 本地模式

你可以任意定义一个方法，如果要将它作为部件，只需要调用 `app.widget.register` 进行注册即可

```js
var widget = function(options){
    var View = app.view.define();
    return new View(options);
};
// 注册部件
app.widget.register('widget1', widget);
```

### 远程模式

我们知道，部件是自成体系的业务构件，因此可能会比较复杂，不可能放到一个文件里面，因此需要另一种组织部件的方式

我们采用的方式是一个部件就是一个文件夹，并且文件夹下的文件组织与 CommonJS 的 [Packages规范](http://wiki.commonjs.org/wiki/Packages/1.1) 类似，默认的定义格式如下：

```js
--styles/
--templates/
--views/
--main.js
```

`main.js` 是整个部件的入口文件，应用程序加载某个部件时，会首先查找并执行该文件，因此该文件应引用其他文件，并最终返回部件主函数。

```js
// main.js
define([
    'text!./templates/main.html'
], function(tpl){
    return function(options){
        var View = app.view.define({
            template: tpl
        });
        return new View(options);
    };
});
```

使用这种方式定义的部件不用进行注册，因为它是启动时异步加载的，但当你要在其他部件中引用某个部件时，需要对要引用的部件进行包声明

```js
app.widget.package();
```

如果不传任何参数，则代表声明所有的部件

## 启动

在某些对象中，如 sandbox、view，有 `startWidgets`方法，该方法用于启动部件，它可以启动一个或一组部件

启动某个部件时，会先在本地所有已注册的部件中查找，如果找到则调用该部件主函数，如果未找到，则根据配置项，从远程特定位置加载该部件，加载完毕后再执行

```
app.sandbox.startWidgets([{
    name: 'widget1',
    options: {
        source: 'basic',
        host: '#content'
    }
}]);
```



